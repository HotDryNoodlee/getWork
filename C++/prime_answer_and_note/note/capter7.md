*   ## 练习7.16：在类的定义中对于访问说明符出现的位置和次数有限定吗？如果有，是什么？什么样的成员应该定义在 public 说明符之后？什么样的成员应该定义在private 说明符之后？ 
    
    *   【出题思路】 
        
        考查访问说明符的用法。     

    *   【解答】 

        在类的定义中，可以包含 0 个或者多个访问说明符，并且对于某个访问说明符能出现多少次以及能出现在哪里都没有严格规定。每个访问说明符指定接下来的成员的访问级别，有效范围直到出现下一个访问说明符或者到达类的结尾为止。 一般来说，作为接口的一部分，构造函数和一部分成员函数应该定义在public说明符之后，而数据成员和作为实现部分的函数则应该跟在private 说明符之后。  
        
*   ## 练习7.17：使用class 和struct 时有区别吗？如果有，是什么？ 
    
    *   【出题思路】 
        
        class 和struct 都可以用来声明类，它们的大多数功能都类似，唯一的区别是默认访问权限不同。 
    
    *   【解答】 

        类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果使用 struct 关键字，则定义在第一个访问说明符之前的成员是public 的；相反，如果使用class 关键字，则这些成员是private 的。


*   ## 练习7.30：通过this 指针使用成员的做法虽然合法，但是有点多余。讨论显式地使用指针访问成员的优缺点。 
    
    *   【出题思路】 

        对比使用this 指针访问成员的利弊。 

    *   【解答】 

        通过this 指针访问成员的优点是，可以非常明确地指出访问的是对象的成员，并且可以在成员函数中使用与数据成员同名的形参；缺点是显得多余，代码不够简洁。  


*   ## 练习7.31：定义一对类X 和Y，其中 X 包含一个指向Y 的指针，而Y 包含一个类型为X 的对象。 
    
    *   【出题思路】 

        理解类的声明和定义。声明的作用是告知程序类的名字合法可用；定义的作用是规定类的细节。 
    
    *   【解答】 

        满足题意的程序如下所示： 
        ```c++
        class X;
        class Y 
        {     
            X* x; 
        }; 
        class X       
        {     
            Y y; 
        };
        ``` 
        类X 的声明称为前向声明，它向程序中引入了名字X 并且指明X 是一种类类型。对于类型X 来说，此时我们已知它是一个类类型，但是不清楚它到底包含哪些成员，所以它是一个不完全类型。我们可以定义指向不完全类型的指针，但是无法创建不完全类型的对象。 
        
        如果试图写成下面的形式，将引发编译器错误。 
        ```C++
        class Y;
        class X 
        {     
            Y y; 
        }; 
        class Y 
        {     
            X* x;
        };   
        ```

        此时我们试图在类X 中创建不完全类型Y 的对象，编译器给出报错信息： 

        error: field 'y' has incomplete type

*   ## 练习7.36：下面的初始值是错误的，请找出问题所在并尝试修改它。 
    ```c++
    struct X 
    { 
        X (int i, int j): base(i), rem(base % j) { } 
        int rem, base; 
    }; 
    ```
    *   【出题思路】 
        
        本题旨在考查使用构造函数初始值列表时成员的初始化顺序，初始化顺序只与数据成员在类中出现的次序有关，而与初始值列表的顺序无关。 

    *   【解答】 
        
        在类 X 中，两个数据成员出现的顺序是 rem 在前，base 在后，所以当执行 X对象的初始化操作时先初始化rem。如上述代码所示，初始化rem 要用到base 的值，而此时base 尚未被初始化，因此会出现错误。该过程与构造函数初始值列表中谁出现在前面谁出现在后面没有任何关系。 
        
        修改的方法很简单，只需要把变量rem 和base 的次序调换即可，形式是： 
        
        ```c++
        struct X 
        { 
            X (int i, int j): base(i), rem(base % j) { } 
            int base, rem; 
        };
        ```

*   ## 练习7.38：有些情况下我们希望提供cin 作为接受istream&参数的构造函数的默认实参，请声明这样的构造函数。 
    
    *   【出题思路】 
        
        可以直接在函数声明的地方为istream&类型的参数设置默认实参cin。 

    *   【解答】 
        
        满足题意的构造函数如下所示： Sales_data(std::istream &is=std::cin) { is >> *this; } 此时该函数具有了默认构造函数的作用，因此我们原来声明的默认构造函数Sales_data()= default;应该去掉，否则会引起调用的二义性。

*   ## 练习 7.39：如果接受 string 的构造函数和接受 istream&的构造函数都使用默认实参，这种行为合法吗？如果不，为什么？ 
    *   【出题思路】 
        
        本题考查使用默认实参对构造函数的影响。 

    *   【解答】 
        
        如果我们为构造函数的全部形参都提供了默认实参（包括为只接受一个形参的构造函数提供默认实参），则该构造函数同时具备了默认构造函数的作用。此时即使我们不提供任何实参地创建类的对象，也可以找到可用的构造函数。 然而，如果按照本题的叙述，我们为两个构造函数同样都赋予了默认实参，则这两个构造函数都具有了默认构造函数的作用。一旦我们不提供任何实参地创建类的对象，则编译器无法判断这两个（重载的）构造函数哪个更好，从而出现了二义性错误。


*   ## 练习7.48：假定Sales_data 的构造函数不是explicit 的，则下述定义将执行什么样的操作？ 
    
    
    ```c++
    string null_isbn("9-999-99999-9"); 
    Sales_data item1(null_isbn); 
    Sales_data item2("9-999-99999-9"); 
    ```

    如果Sales_data 的构造函数是explicit 的，又会发生什么呢？ 

    *   【出题思路】

        构造函数如果不是explicit 的，则 string 对象隐式地转换成Sales_data对象；相反，构造函数如果是explicit 的，则隐式类类型转换不会发生。 
    
    *   【解答】 
        
        在本题给出的代码中，第一行创建了一个 string 对象，第二行和第三行都是调用Sales_data 的构造函数（该构造函数接受一个string）创建它的对象。此处无须任何类类型转换，所以不论Sales_data 的构造函数是不是explicit 的，item1 和item2 都能被正确地创建，它们的bookNo 成员都是9-999-99999-9，其他成员都是0。  

*   ## 练习 7.49：对于 combine 函数的三种不同声明，当我们调用 i.combine(s)时分别发生什么情况？其中i 是一个Sales_data，而s 是一个string 对象。 

    (a) Sales_data &combine(Sales_data); 

    (b) Sales_data &combine(Sales_data&); 

    (c) Sales_data &combine(const Sales_data&) const; 

    *   【出题思路】 

        要想使用隐式的类类型转换，必须遵循一系列规定。如果我们试图在一行代码中使用两种转换规则，编译器将报错。 

    *   【解答】 
        
        (a)是正确的，编译器首先用给定的string 对象s 自动创建一个Sales_data对象，然后这个新生成的临时对象传给combine 的形参（类型是Sales_data），函数正确执行并返回结果。
        
        (b)无法编译通过，因为 combine 函数的参数是一个非常量引用，而 s 是一个string 对象，编译器用s 自动创建一个Sales_data 临时对象，但是这个新生成的临时对象无法传递给 combine 所需的非常量引用。如果我们把函数声明修改为Sales_data &combine(const Sales_data&);就可以了。 
        
        (c)无法编译通过，因为我们把combine 声明成了常量成员函数，所以该函数无法修改数据成员的值。


*   ## 练习7.56：什么是类的静态成员？它有何优点？静态成员与普通成员有何区别？ 

    *   【出题思路】 

        本题考查静态成员的含义及用法。 
        
    *   【解答】 

        静态成员是指声明语句之前带有关键字 static 的类成员，静态成员不是任意单独对象的组成部分，而是由该类的全体对象所共享。 静态成员的优点包括：作用域位于类的范围之内，避免与其他类的成员或者全局作用域的名字冲突；可以是私有成员，而全局对象不可以；通过阅读程序可以非常容易地看出静态成员与特定类关联，使得程序的含义清晰明了。 静态成员与普通成员的区别主要体现在普通成员与类的对象关联，是某个具体对象的组成部分；而静态成员不从属于任何具体的对象，它由该类的所有对象共享。另外，还有一个细微的区别，静态成员可以作为默认实参，而普通数据成员不能作为默认实参。