* ## 练习12.8：下面的函数是否有错误？如果有，解释错误原因。 
    ```c++
    bool b() 
    { 
        int* p = new int; // ... 
        return p; 
    }
    ``` 

    *   【出题思路】 
        
        理解用new 分配内存成功和失败的差别，以及复习类型转换。 
    
    *   【解答】 

        从程序片段看，可以猜测程序员的意图是通过 new 返回的指针值来区分内存分配成功或失败——成功返回一个合法指针，转换为整型是一个非零值，可转换为bool值true；分配失败，p得到nullptr，其整型值是0，可转换为bool值false。 但普通new调用在分配失败时抛出一个异常bad_alloc，而不是返回nullptr，因此程序不能达到预想的目的。 可将new int 改为new (nothrow) int 来令new 在分配失败时不抛出异常，而是返回nullptr。但这仍然不是一个好方法，应该通过捕获异常或是判断返回的指针来返回true 或false，而不是依赖类型转换。

* ## 练习12.9：解释下面代码执行的结果： 

    ```C++
    int *q = new int(42), *r = new int(100); r = q; 
    auto q2 = make_shared<int>(42), r2 = make_shared<int>(100); r2 = q2; 
    ```

    *   【出题思路】 

        理解直接管理内存和智能指针的差别。 

    *   【解答】 

        这段代码非常好地展示了智能指针在管理内存上的优点。 对于普通指针部分，首先分配了两个 int 型对象，指针分别保存在 p 和 r 中。接下来，将指针q 的值赋予了r，这带来了两个非常严重的内存管理问题： 1．首先是一个直接的内存泄漏问题，r 和 q 一样都指向 42 的内存地址，而 r中原来保存的地址——100 的内存再无指针管理，变成“孤儿内存”，从而造成内存泄漏。 2．其次是一个“空悬指针”问题。由于r 和q 指向同一个动态对象，如果程序编写不当，很容易产生释放了其中一个指针，而继续使用另一个指针的问题。继续使用的指针指向的是一块已经释放的内存，是一个空悬指针，继续读写它指向的内存可能导致程序崩溃甚至系统崩溃的严重问题。 

        而shared_ptr 则可很好地解决这些问题。首先，分配了两个共享的对象，分别由共享指针p2 和q2 指向，因此它们的引用计数均为1。接下来，将q2 赋予r2。赋值操作会将q2指向的对象地址赋予r2，并 将r2原来指向的对象的引用计数减1，将q2 指向的对象的引用计数加1。这样，前者的引用计数变为0，其占用的内存空间会被释放，不会造成内存泄漏。而后者的引用计数变为 2，也不会因为 r2 和 q2之一的销毁而释放它的内存空间，因此也不会造成空悬指针的问题。


* ## 练习12.10：下面的代码调用了第413 页中定义的process 函数，解释此调用是否正确。如果不正确，应如何修改？ 
    
    ```C++
    shared_ptr<int> p(new int(42)); process(shared_ptr<int>(p)); 
    ```
    
    *   【出题思路】 

        理解智能指针的使用。 

    *   【解答】 

        此调用是正确的，利用p 创建一个临时的shared_ptr 赋予process 的参数ptr，p 和ptr 都指向相同的int 对象，引用计数被正确地置为2。process 执行完毕后，ptr 被销毁，引用计数减1，这是正确的——只有p 指向它。  


* ## 练习12.11：如果我们像下面这样调用process，会发生什么？ 
    
    ```C++
    process(shared_ptr<int>(p.get())); 
    ```
    
    *   【出题思路】 
        
        理解智能指针和普通指针不能混用。 
    
    *   【解答】 

        此调用是错误的。p.get()获得一个普通指针，指向p 所共享的int 对象。利用此指针创建一个shared_ptr，而不是利用p 创建一个shared_ptr，将不会形成正确的动态对象共享。编译器会认为p 和ptr 是使用两个地址（虽然它们相等）创建的两个不相干的 shared_ptr，而非共享同一个动态对象。这样，两者的引用计数均为1。当process 执行完毕后，ptr 的引用计数减为0，所管理的内存地址被释放，而此内存就是p 所管理的。p 成为一个管理空悬指针的shared_ptr。


* ## 练习 12.17：下面的 unique_ptr 声明中，哪些是合法的，哪些可能导致后续的程序错误？解释每个错误的问题在哪里。 
    
    ```c++
    int ix = 1024, *pi = &ix, *pi2 = new int(2048); typedef unique_ptr<int> IntP; 
    (a) IntP p0(ix);         (b) IntP p1(pi); 
    (c) IntP p2(pi2);        (d) IntP p3(&ix); 
    (e) IntP p4(new int(2048));    (f) IntP p5(p2.get()); 
    ```
    *   【出题思路】 

        继续熟悉unique_ptr 使用上应注意的问题。 
    
    *   【解答】 

        (a)不合法。unique_ptr 需要用一个指针初始化，无法将int 转换为指针。 
        
        (b)合法。可以用一个 int *来初始化 IntP，但此程序逻辑上是错误的。它用一个普通int 变量的地址初始化p1，p1 销毁时会释放此内存，其行为是未定义的。 
        
        (c)合法。用一个指向动态分配的对象的指针来初始化IntP 是正确的。 (d)合法。但存在与(b)相同的问题。 
        
        (e)合法。与(c)类似。 
        
        (f)合法。但用p2 管理的对象的地址来初始化p5，造成两个unique_ptr 指向相同的内存地址。当其中一个unique_ptr 被销毁（或调用reset 释放对象）时，该内存被释放，另一个unique_ptr 变为空悬指针。