## 一条SQL查询语句是如何执行的？

1. 连接器：建立连接，管理连接、校验用户身份； 

2. 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
 
3. 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型； 执行 SQL：

4. 执行 SQL 共有三个阶段： 
   * 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。 
   * 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划； 
   * 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

## 事务的四大特性有哪些？

1. 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。 

2. 一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。 

3. 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。 

4. 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

* 持久性是通过 redo log （重做日志）来保证的； 
* 原子性是通过 undo log（回滚日志） 来保证的； 
* 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； 
* 一致性则是通过持久性+原子性+隔离性来保证；

## 数据库的事务隔离级别有哪些？

1. 读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到； 
2. 读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到； 
3. 可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 
4. 串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

## MyISAM和InnoDB的区别

1. 事务支持
InnoDB：支持ACID事务（Atomicity, Consistency, Isolation, Durability），提供了事务回滚、提交、崩溃恢复等功能。这使得InnoDB能够保证数据的一致性和可靠性，尤其适合需要事务管理的应用场景。
MyISAM：不支持事务。这意味着MyISAM无法保证多条SQL语句在执行过程中，要么全部成功，要么全部失败（原子性），数据的一致性难以保证。
2. 锁机制
InnoDB：使用行级锁定（Row-level Locking），在进行数据操作时只锁定相关的行，而不会锁定整个表。这种锁定方式提高了高并发环境下的性能和可扩展性。
MyISAM：使用表级锁定（Table-level Locking），在进行数据操作时会锁定整个表。这种锁定机制在高并发写操作下，容易导致性能瓶颈。
3. 外键支持
InnoDB：支持外键约束，能够维护表与表之间的数据完整性。这对于数据表之间存在关联关系的情况非常重要。
MyISAM：不支持外键约束，表之间的关系需要通过应用程序逻辑来维持。
4. 数据存储方式
InnoDB：InnoDB将数据存储在一个共享表空间或独立表空间中（每张表一个.ibd文件），并使用聚簇索引（Clustered Index），即数据和索引存储在同一个结构中。InnoDB的数据文件较为庞大，但数据的一致性和完整性得到了更好的保障。
MyISAM：MyISAM将表的数据和索引分别存储在不同的文件中，表数据存储在.MYD文件中，索引存储在.MYI文件中。MyISAM的数据文件较为紧凑，空间占用较小。
5. 崩溃恢复
InnoDB：支持自动崩溃恢复。在系统崩溃或意外关机后，InnoDB可以通过事务日志自动恢复数据，减少数据丢失的风险。
MyISAM：崩溃恢复能力较弱。MyISAM在系统崩溃或断电时，可能会导致数据损坏或丢失，且恢复过程需要手动进行。

## MySQL为什么使用B+树来作索引

1. B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。 
2. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化； 
3. B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。


## 什么是慢查询？原因是什么？可以怎么优化？

慢查询指的是在数据库中执行时间超过预设阈值的查询语句。MySQL默认的慢查询阈值是10秒，但可以根据实际需求进行调整。慢查询往往会导致数据库性能下降，影响整体系统的响应速度。

* 慢查询的原因

  1. 缺少索引：
  2. 数据量大：
  3. 查询不优化：
  4. 查询语句不够优化，如使用了不必要的全表扫描、子查询或复杂的连接操作。
  5. 服务器资源瓶颈：
  6. 锁争用：

* 优化慢查询的方法

  1. 创建和优化索引：
  2. 使用覆盖索引（Covering Index），在索引中包含查询所需的所有字段，减少访问表的次数。
  3. 优化查询语句：


## undo log、redo log、binlog 有什么用？

1. undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC
2. redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
3. binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；

## MySQL有哪些锁

   1. 全局锁 
      * 全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
   2. 表极锁

      * 表锁；

      * 元数据锁（MDL）;
        * 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
        * 对一张表做结构变更操作的时候，加的是 MDL 写锁；
     
      * 意向锁；
         * 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
         * 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
         * 意向锁的目的是为了快速判断表里是否有记录被加锁。

      * AUTO-INC 锁；
        * Record Lock
        * Gap Lock
          * 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
        * Next-Key Lock
        * 插入意向锁
          * 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。 如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

   3. 行级锁

## MySQL和Redis的区别是什么

## Redis有什么优缺点？为什么用Redis查询会比较快

## Redis的数据类型有哪些？

## Redis是单线程的还是多线程的，为什么？

## 说一说Redis持久化机制有哪些

## 介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？

## 如何保证数据库和缓存的一致性

## SQL里面的内连接和外连接是什么，有什么区别？

## SQL注入是什么，怎么避免？

## 数据库索引是什么，如何实现的，为什么用索引更加高效？

## 联合索引查询

## 什么时候不适合加索引

## 什么是队头阻塞？怎么解决？

## Redis的大key是什么？怎么解决？

## Redis的热key是什么？怎么解决？