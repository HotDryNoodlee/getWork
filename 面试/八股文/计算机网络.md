## 介绍一下TCP/IP模型和OSI模型的区别

OSI模型， 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，将计算机网络通信划分为七个不同的层级，每个层级都负责特定的功能。每个层级都构建在其下方的层级之上，并为上方的层级提供服务。七层从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。虽然OSI模型在理论上更全面，但在实际网络通信中，TCP/IP模型更为实用。 TCP/IP模型分为四个层级，每个层级负责特定的网络功能。

* 应用层：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。它为网络上的各种应用程序提供服务，如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。

* 传输层：该层对应OSI模型的传输层。它负责端到端的数据传输，提供可靠的、无连接的数据传输服务。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。

* 网络层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。

* 网络接口层：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。


## 从输入 URL 到页面展示到底发生了什么？

1. 输入网址，解析URL信息，准备发送HTTP请求
2. 检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。
3. DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。DNS解析时会按本地浏览器缓存->本地Host文件->路由器缓存->DNS服务器->根DNS服务器的顺序查询域名对应IP，直到找到为止。
4. TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。
5. 客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。
6. 服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。
7. TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。
8. 浏览器解析响应并渲染页面：
浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。
浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

## GET请求和POST请求的区别
1. get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。

2. get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，
不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；
post请求是没有的长度限制，请求数据是放在body中；

1. get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。

2. get请求可以被缓存，post请求不会被缓存。

3. get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。

4. get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。

* 深入理解
  1. GET 和 POST都是http请求方式， 底层都是 TCP/IP协议；通常GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包（但firefox是发送一个数据包），

  2. 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200
  （返回数据）表示成功；而对于 POST，浏览器先发送 header，服务器响应 100， 浏览器再继续发送 data，服务器响应 200 （返回数据）。

## 什么是强缓存和协商缓存

1. 强缓存

    强缓存是一种强制性的缓存机制，一旦资源被缓存，浏览器在一定时间内就不会向服务器发送请求，直接从本地缓存中读取资源。这样可以避免不必要的网络请求，提高网页加载速度。

    在HTTP/1.1协议中，强缓存主要通过两个头部字段来实现：Expires和Cache-Control。

    Expires: 该字段指定了资源过期的时间戳。浏览器会在本地创建一个时间戳，与服务器返回的过期时间戳进行比较。如果本地时间戳小于服务器返回的时间戳，则认为资源未过期，可以直接从本地缓存中读取；否则，认为资源已过期，需要重新向服务器请求。
    Cache-Control: 该字段是强缓存机制的核心，它提供了一个更加灵活的缓存控制机制。通过设置不同的指令，如max-age、no-cache、no-store等，可以控制资源的缓存行为。例如，max-age=3600表示资源在3600秒内不会过期；no-cache表示需要向服务器验证资源的有效性；no-store表示禁止缓存资源。
    需要注意的是，强缓存可能导致“硬刷新”问题。当浏览器强制刷新页面时，即使资源的缓存时间未过期，浏览器也会忽略本地缓存，直接向服务器发送请求。为了避免这种情况，开发者可以在服务器端设置Cache-Control: no-cache或Cache-Control: no-store，这样浏览器在每次请求资源时都会向服务器验证资源的有效性。

2. 协商缓存

    协商缓存是一种可选的缓存机制，它允许浏览器和服务器在资源过期后进行协商，以确定是否使用本地缓存的资源。协商缓存主要通过两个头部字段来实现：Last-Modified和ETag。

    Last-Modified: 该字段指定了资源的最后修改时间。当浏览器向服务器发送请求时，会带上本地缓存的资源的最后修改时间戳。服务器会与当前资源的实际修改时间进行比较，如果一致，则认为资源未修改，返回一个304 Not Modified状态码，告诉浏览器可以直接使用本地缓存的资源；否则，认为资源已修改，需要重新下载资源。
    ETag: 该字段提供了一种更加精确的资源验证机制。与Last-Modified相比，ETag是基于资源的特定内容生成的一个唯一标识符。当资源内容发生变化时，ETag也会随之变化。浏览器向服务器发送请求时，会带上本地缓存的资源的ETag。服务器会与当前资源的ETag进行比较，如果一致，则认为资源未修改；否则，认为资源已修改。
    在实际开发中，为了获得更好的缓存效果，可以将强缓存和协商缓存结合使用。首先使用强缓存来减少不必要的网络请求，当资源过期或发生硬刷新时，再通过协商缓存来验证资源的有效性。通过合理配置HTTP缓存头部字段，可以有效提高网页加载速度，提升用户体验。

## HTTP中常见的状态码有哪些？

   1. 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
   2. 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
      *   「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 
      *   「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 
      *   「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
   3. 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
       * 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
       * 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
       * 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
   4. 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
      * 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 
      * 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 
      * 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

   5. 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 
      * 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 
      * 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 
      * 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 
      * 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。


## http1.0, 1.1, 2.0, 3.0

## http和https

## tcp和udp
   1. TCP是面向连接的，UDP是无连接的
   2. TCP是可靠的，UDP是不可靠的
   3. TCP是面向字节流的，UDP是面向数据报文的
   4. TCP只支持点对点通信，UDP支持一对一，一对多，多对多
   5. TCP报文首部20个字节，UDP首部8个字节
   6. TCP有拥塞控制机制，UDP没有
   7. TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区

## TCP连接如何确保可靠性
 
TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。为确保可靠性，TCP实现了以下机制：
### 1. 三次握手（Three-Way Handshake）
- **SYN**：客户端发送一个SYN报文到服务器，并进入SYN_SENT状态，开始连接。
- **SYN-ACK**：服务器收到SYN报文后，会发送一个SYN-ACK报文作为应答，并将连接状态设置为SYN_RECEIVED。
- **ACK**：客户端收到服务器的SYN-ACK报文后，会向服务器发送一个ACK报文，并进入ESTABLISHED状态，服务器在收到ACK报文后也进入ESTABLISHED状态。
  
这个过程确保了双方都知道对方已经准备好接收数据。

### 2. 数据传输
- **序列号和确认应答**：TCP给发送的每个数据包分配一个序列号，并且接收方会发送确认应答（ACK）来确认已成功接收的数据。如果发送方在指定的时间内没有收到确认应答，它会重新发送数据。
- **流量控制**：TCP使用滑动窗口机制来控制发送方的发送速率，以避免接收方来不及处理。

### 3. 数据校验
- **校验和**：TCP头部包含一个校验和字段，用于检测数据在传输过程中的任何变化。如果校验和不匹配，TCP会丢弃该数据包，并等待重传。

### 4. 数据重传
- **超时重传**：如果发送方在预期时间内没有收到确认应答，它会认为数据包丢失或出错，并会重新发送该数据包。
- **快速重传**：如果发送方接收到三个重复的ACK，它会立即重传丢失的数据包，而不是等待超时。
### 5. 拥塞控制
- **慢启动**：TCP连接开始时，会采用慢启动算法来逐渐增加发送数据的速率，以避免网络拥塞。
- **拥塞避免**：当网络拥塞发生时，TCP会减少其发送速率，以减轻网络负担。
- **快速恢复**：在某些情况下，TCP可以快速恢复到拥塞发生前的状态，而不是从慢启动重新开始。

通过这些机制，TCP能够确保数据的可靠传输，即使在网络条件不佳的情况下也能维持连接的稳定性。


## 拥塞控制是怎么实现的嘛
拥塞控制是TCP协议中一个非常重要的组成部分，它的目的是防止过多的数据注入到网络中，从而使网络中的路由器或链路不会过载。拥塞控制的实现主要通过以下几种算法和机制来完成：
### 1. 慢启动（Slow Start）
- **初始窗口**：当TCP连接开始时，其拥塞窗口（cwnd）通常设置为一个较小的值，比如1个最大报文段（MSS）。
- **指数增长**：在每次收到确认应答（ACK）后，cwnd会加倍增长，这个过程称为指数增长。
- **慢启动阈值（ssthresh）**：当cwnd达到一个预设的阈值ssthresh时，慢启动过程结束，拥塞控制进入下一个阶段。
### 2. 拥塞避免（Congestion Avoidance）
- **线性增长**：在拥塞避免阶段，每经过一个往返时间（RTT），cwnd只增加1个MSS，而不是像慢启动那样加倍增长。
- **调整ssthresh**：当网络发生拥塞（如检测到丢包）时，ssthresh会被设置为发生拥塞时的cwnd的一半，然后cwnd会被重置为一个较小的值，通常是1个MSS，重新开始慢启动过程。
### 3. 快速重传和快速恢复（Fast Retransmit and Fast Recovery）
- **快速重传**：当发送方收到三个重复的ACK时，它会立即重传丢失的数据包，而不需要等待重传计时器超时。
- **快速恢复**：在快速重传后，cwnd被设置为ssthresh加上3个MSS的大小，然后进入拥塞避免阶段，而不是慢启动。
- **减少cwnd**：对于后续收到的每个重复ACK，cwnd增加1个MSS，直到收到新的数据包的ACK。
### 4. 拥塞窗口（cwnd）和通告窗口（rwnd）
- **cwnd**：拥塞窗口是发送方维护的一个变量，用来限制发送方在任意时刻可以发送到网络中的数据量。
- **rwnd**：通告窗口是接收方维护的一个变量，用来告诉发送方它的接收缓冲区还能接收多少数据。
### 实现步骤
1. **初始化**：TCP连接开始时，设置cwnd为一个小的值，ssthresh为一个较大的值。
2. **慢启动**：在慢启动阶段，cwnd以指数方式增长，直到达到ssthresh。
3. **拥塞避免**：当cwnd达到ssthresh后，进入拥塞避免阶段，cwnd以线性方式增长。
4. **检测拥塞**：如果发生丢包，认为网络出现拥塞，调整ssthresh和cwnd，可能重新开始慢启动或快速恢复。
5. **调整窗口**：根据网络状况调整cwnd的大小，以避免发送过多的数据导致网络拥塞。
通过这些算法和机制，TCP能够动态地调整其发送速率，以适应网络当前的拥塞状况，从而提高网络的总体性能和稳定性。

## TCP流量控制是怎么实现的？
流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。

   * 滑动窗口大小： 在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。

   * 接收方窗口大小： 接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。

   * 流量控制的目标： 流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。

   * 动态调整： 发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。

   * 确认机制： 接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。
## UDP怎么实现可靠传输

## TCP连接三次握手的过程，为什么是三次，可以是两次或者更多吗？
1. 三次握手才可以阻止重复历史连接的初始化（主要原因）
   * 如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。 因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。 所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。
2. 三次握手才可以同步双方的初始序列号
3. 三次握手才可以避免资源浪费
## TCP连接四次挥手的过程，为什么是四次？
   * 为了确保双方数据都发送完毕如果只是三次挥手，有可能被动方还有数据未发送完毕。
## HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？
1. HTTP的Keep-Alive是一种机制，用于在HTTP连接中保持TCP连接的打开状态，以便在同一个连接上发送多个请求和响应，而不需要为每个请求和响应都建立一个新的TCP连接。Keep-Alive减少了建立和关闭连接的次数，从而提高了性能。

2. TCP的Keepalive是一种机制，用于检测连接是否仍然活跃。当TCP连接长时间没有数据传输时，操作系统可能会发送一个Keepalive探测包到对端，如果对端收到这个探测包并响应，则连接仍然被认为是活跃的。如果对端没有响应，则操作系统可能会认为连接已经死亡，并最终关闭连接。
## DNS查询过程

## Cookie和Session是什么？有什么区别？
1. Cookie和Session是什么？

   Cookie 和 Session 都用于管理用户的状态和身份, Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。

   * Cookie
      通常，服务器会将一个或多个 Cookie 发送到用户浏览器，然后浏览器将这些 Cookie 存储在本地。
      服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。
   *  Session
      客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。Session 主要用于维护用户登录状态、存储用户的临时数据和上下文信息等。服务器为每个用户分配一个唯一的Session ID，通常存储在Cookie中。

2. Cookie和Session的区别？

   * 存储位置：Cookie 数据存储在用户的浏览器中，而 Session 数据存储在服务器上。
   * 数据容量：Cookie 存储容量较小，一般为几 KB。Session 存储容量较大，通常没有固定限制，取决于服务器的配置和资源。
   * 安全性：由于 Cookie 存储在用户浏览器中，因此可以被用户读取和篡改。相比之下，Session 数据存储在服务器上，更难被用户访问和修改。
   * 生命周期：Cookie可以设置过期时间，Session 依赖于会话的持续时间或用户活动。
   * 传输方式：Cookie 在每次 HTTP 请求中都会被自动发送到服务器，而 Session ID 通常通过 Cookie 或 URL 参数传递。

## rpc实现原理
远程过程调用（RPC, Remote Procedure Call）是一种允许程序调用另一个地址空间（通常是一个远程计算机上）的过程或函数的技术，而使得开发者无需额外地为这个交云通信过程编程。RPC的实现原理大致如下：
### 1. RPC模型的基本组件：
- **客户端（Client）**：发起RPC调用的程序。
- **服务器端（Server）**：提供远程服务的程序。
- **RPC请求**：客户端发送给服务器端的调用请求。
- **RPC响应**：服务器端返回给客户端的调用结果。
### 2. RPC的工作流程：
1. **客户端调用**：
   - 客户端以本地方式调用一个过程（函数），这个过程实际上是一个客户端stub（存根）。
   
2. **封包**：
   - 客户端stub将调用信息（如调用的过程标识、参数等）打包成一个消息，准备发送给服务器端。
3. **发送请求**：
   - 客户端通过底层网络协议（如TCP、UDP）将消息发送给服务器端。
4. **服务器端接收**：
   - 服务器端接收到消息后，服务器端stub将其解包。
5. **执行调用**：
   - 服务器端stub根据调用信息调用在服务器端实际运行的函数（称为服务器端实现），并传递参数。
6. **返回结果**：
   - 服务器端实现完成调用后，将结果返回给服务器端stub。
7. **封包响应**：
   - 服务器端stub将执行结果打包，发送回客户端。
8. **客户端接收响应**：
   - 客户端stub接收到消息后，解包并将结果返回给客户端的调用者。
### 3. RPC的关键技术：
- **协议**：定义了RPC消息的格式和调用过程中消息的交换顺序。
- **序列化/反序列化**：将数据结构或对象状态转换成可存储或传输的格式的过程，以及从这种格式恢复数据结构的过程。
- **网络通信**：RPC依赖于网络通信协议（如TCP、UDP）来传输数据。
- **stub/skeleton**：
  - **stub**：存在于客户端，它实现了与服务器端相同的方法，但实际上并不执行任何操作，而是将调用信息打包并发送到服务器端。
  - **skeleton**：存在于服务器端，它接收请求、解包参数，并调用实际的服务器端实现。
### 4. RPC的类型：
- **同步RPC**：客户端在发送请求后，会阻塞等待服务器端返回结果。
- **异步RPC**：客户端发送请求后，可以继续执行其他任务，而不必等待服务器端的响应。
RPC的实现隐藏了网络通信的细节，使得远程函数调用看起来像本地函数调用一样简单。常见的RPC框架包括gRPC、Thrift、XML-RPC、JSON-RPC等。

## tcp标志位
 1. URG(Urgent，紧急标志)：当设置此位值时，数据优先于其它数据。表示数据包所携带的数据应立即由TCP堆栈处理。表明发送端向另一端使用紧急方式发送数据，包中有需要紧急处理的数据。

 2. ACK(Acknowledgment，确认标志)：应答响应，这个位字段在连接建立(三次握手)和数据传输期间使用。用于确认数据包已经收到，也用于确认发起请求和拆除请求。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1。

 3. PSH(Push，推送标志)：这个位字段告诉应用程序立即发送数据。表示传入的数据应该直接传递给应用程序，而不是被缓存。PSH为0，也就是普通情况下，则不需要立即传，而是先进行缓存。

 4. RST(Reset，重置标志)：这个位字段设置是为了重置TCP连接。表示连接已关闭，或者服务可能不接受请求。表示TCP连接中出现异常必须强制断开连接。RST标志用于中止连接，经常用它解决网络连接问题。

 5. SYN(Synchronization，同步标志)：这个位标志用于发起一个连接，建立连接并设置初始序列号。

 6. FIN(Finish，完成标志)：这个位字段表示TCP连接的结束，表示正在断开连接或关闭连接。发送方和接收方都发送FIN包以终止连接。表示发送方完成任务，今后不会有数据发送，希望断开连接。当通信结束希望断开连接，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。FIN标志用于终止TCP连接。